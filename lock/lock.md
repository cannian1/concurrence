### 主干流程

- Mutex内一个状态值标识锁的标志，例如，取0表示未加锁，取1表示已加锁;
- 上锁：把0改为1;
- 解锁：把1改为0
- 上锁时若已经为1，则上锁失败，需要等待他人解锁，将状态改为0

### 由自旋到阻塞的升级过程（针对性能的考量）

针对 goroutine 加锁时发现锁已被抢占的这种情形，此时摆在面前的策略有如下两种：

- 阻塞/唤醒：将当前 goroutine 阻塞挂起，直到锁被释放后，以回调的方式将阻塞 goroutine 重新唤醒，进行锁争夺；
- 自旋 + CAS：基于自旋结合 CAS 的方式，重复校验锁的状态并尝试获取锁，始终把主动权握在手中.

上述方案各有优劣，且有其适用的场景：

| **锁竞争方案** | **优势**                       | **劣势**                               | **适用场景**         |
| -------------- | ------------------------------ | -------------------------------------- | -------------------- |
| 阻塞/唤醒      | 精准打击，不浪费 CPU 时间片    | 需要挂起协程，进行上下文切换，操作较重 | 并发竞争激烈的场景   |
| 自旋+CAS       | 无需阻塞协程，短期来看操作较轻 | 长时间争而不得，会浪费 CPU 时间片      | 并发竞争强度低的场景 |

sync.Mutex 结合两种方案的使用场景，制定了一个锁升级的过程，反映了面对并发环境通过持续试探逐渐由乐观逐渐转为悲观的态度，具体方案如下：

- 首先保持乐观，goroutine 采用自旋 + CAS 的策略争夺锁；
- 尝试持续受挫达到一定条件后，判定当前过于激烈，则由自旋转为 阻塞/挂起模式.

由自旋模式转为阻塞模式的具体条件有以下几种：

-  自旋累计达到 4 次仍未取得战果；
- CPU 单核或仅有单个 P 调度器；（此时自旋，其他 goroutine 根本没机会释放锁，自旋纯属空转）；
- 当前 P 的执行队列中仍有待执行的 G. （避免因自旋影响到 GMP 调度效率）.

### 饥饿模式（针对公平性的考量）

- **饥饿：** 顾名思义，是因为非公平机制的原因，导致 Mutex 阻塞队列中存在 goroutine 长时间取不到锁，从而陷入饥荒状态；
- **饥饿模式：** 当 Mutex 阻塞队列中存在处于饥饿态的 goroutine 时，会进入模式，将抢锁流程由非公平机制转为公平机制.

在 sync.Mutex 运行过程中存在两种模式：

- 正常模式/非饥饿模式：这是 sync.Mutex 默认采用的模式. 当有 goroutine 从阻塞队列被唤醒时，会和此时先进入抢锁流程的 goroutine 进行锁资源的争夺，假如抢锁失败，会重新回到阻塞队列头部.

（值得一提的是，此时被唤醒的老 goroutine 相比新 goroutine 是处于劣势地位，因为新 goroutine 已经在占用 CPU 时间片，且新 goroutine 可能存在多个，从而形成多对一的人数优势，因此形势对老 goroutine 不利.）

- 饥饿模式：这是 sync.Mutex 为拯救陷入饥荒的老 goroutine 而启用的特殊机制，饥饿模式下，锁的所有权按照阻塞队列的顺序进行依次传递. 新 goroutine 进行流程时不得抢锁，而是进入队列尾部排队.

两种模式的转换条件：

-  默认为正常模式；
- 正常模式 -> 饥饿模式：当阻塞队列存在 goroutine 等锁超过 1ms 而不得，则进入饥饿模式；
- 饥饿模式 -> 正常模式：当阻塞队列已清空，或取得锁的 goroutine 等锁时间已低于 1ms 时，则回到正常模式.

正常模式灵活机动，性能较好；饥饿模式严格死板，但能捍卫公平的底线